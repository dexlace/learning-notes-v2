# 多线程
## 1. synchronized关键字  
### 1.0 synchronized锁定的是对象，不是代码块  
### 1.1 锁的是堆内存对象  
### 1.2 synchronized可以修饰代码块，代码块执行完锁释放  
![](./_v_images/20190810231127693_18702.png =816x)  

![]()

### 1.3 synchronized可以锁定this对象，这样的话，一定要得到某个类实例的this对象，才能执行其中的代码  
![](_v_images/20190810232017386_13405.png =808x)  
### 1.4 synchronized可以修饰方法，此时默认锁定this对象  
![](_v_images/20190810232500126_29418.png =768x)  
### 1.5 synchronized修饰静态方法或静态方法中的代码块，则锁定的是类对象  
![](_v_images/20190810232629726_25028.png =779x)  
### 1.6 同步方法和非同步方法可以同时调用  
![](_v_images/20190811000830171_20963.png =866x)  
### 1.7 业务代码写代码需要加锁，最好读代码也要加锁，否则可能会脏读  
### 1.8 synchronized 是可重入锁，也就是一个同步方法可以调用另一个同步方法  
![](_v_images/20190811005127698_22257.png =775x)  
### 1.9 子类的同步方法可以调用父类的同步方法  
![](_v_images/20190811005918746_25908.png =598x)  
### 1.10 同步方法或代码块中异常抛出不处理会释放锁，所以最好加上异常处理  
![](_v_images/20190811010522325_18709.png =1047x)  
### 1.11 锁对象的属性改变不会影响锁的使用，但是锁的对象改变会影响  
![](_v_images/20190811020248982_22576.png =633x)   
![](_v_images/20190811020306198_19527.png =728x)  
### 1.12 不要把字符串常量对象作为锁对象  
![](_v_images/20190811020510363_23680.png =660x)  
## 2. volatile关键字  
### 2.1 volatile可以实现无锁同步，但能力有限  
![](_v_images/20190811012836671_15718.png =924x)  
![](_v_images/20190811012635717_23920.png =737x)  
### 2.2 volatile可以保证可见性，但并不保证原子性，synchronized
### 2.3 Actomic类可以解决volatile的不保证原子性的问题，但是不保证连续调用该类的方法的原子性，此时不需要加synchronized  
![](_v_images/20190811014934877_416.png =900x)  
![](_v_images/20190811015040326_19408.png =832x)  
### 2.4 细粒度的锁要比高粒度的锁性能高很多  
![](_v_images/20190811015713621_29602.png =625x)  
![](_v_images/20190811015731431_7417.png =637x)  
## 3. 淘宝面试题：实现一个容器，提供两个方法，add，size 写两个线程，线程1添加10个元素到容器中，线程2实现监控元素的个数，当个数到达5时，线程2给出提示并结束  
### 3.1 错误示例：连可见性都没保证  
![](_v_images/20190811124116087_16561.png =758x)  
![](_v_images/20190811124151791_409.png =676x)  
### 3.2 勉强合格：对容器对象加volatile，但是还是有问题  
![](_v_images/20190811124359134_11749.png =1103x)  
### 3.3 不加volatile，加锁,应用notify和wait方法，注意wait释放锁，notify不释放锁  
![](_v_images/20190811125101721_2914.png =1082x)  
### 3.4 用线程间通信的方法：CountDownLatch    
![](_v_images/20190811125914683_32121.png =742x)  
![](_v_images/20190811130253948_12502.png =910x)  
## 4. 替代synchronized：ReentrantLock手动锁  
### 4.1 ReentrantLock不会自动释放锁，需要在手动释放锁  
![](_v_images/20190811131826039_24601.png =1035x)  
### 4.2 ReentrantLock可以用尝试去拿锁的方法  
![](_v_images/20190811135644203_1273.png =724x)  
### 4.3 lockInterruptibly这个方法可以响应打断本线程的等待  
![](_v_images/20190811143024689_942.png =796x)  
### 4.4 ReentrantLock可以指定为公平锁，synchronized不可以  
![](_v_images/20190811143825626_15571.png =780x)  
## 5. 面试题：生产者消费者模式实现  
![](_v_images/20190815112520416_21253.png =933x)  
![](_v_images/20190815140240061_16137.png =965x)  
## 6. 线程局部变量ThreadLocal  
![](_v_images/20190831172043604_19541.png =759x)  
