# zookeeper-分布式协调者

## 1、zookeeper的选举机制

1. ==半数机制：集群中半数以上机器存活，集群可用。所以zookeeper适合装在<font color=red>奇数台机器上</font>==
2. Zookeeper虽然在配置文件中并没有指定master和slave。但是，zookeeper工作时，是有一个节点为leader，其他则为follower，Leader是通过内部的选举机制临时产生的。

>  以一个简单的例子来说明整个选举的过程。

假设有五台服务器组成的zookeeper集群，它们的id从1-5，同时它们都是最新启动的，也就是没有历史数据，在存放数据量这一点上，都是一样的。假设这些服务器依序启动，来看看会发生什么。

<img src="zookeeper%E7%AC%94%E8%AE%B0.assets/image-20210228095434812.png" alt="image-20210228095434812" style="zoom:80%;" />

（1）==服务器1启动==，此时只有它一台服务器启动了，它发出去的信息没有任何响应，所以它的选举状态==一直是LOOKING状态==。

（2）==服务器2启动==，它与最开始启动的服务器1进行通信，互相交换自己的选举结果，由于两者都没有历史数据，所以id值较大的服务器2胜出，但是由于==没有达到超过半数以上==的服务器都同意选举它(这个例子中的半数以上是3)，所以==服务器1、2还是继续保持LOOKING状态==。

（3）==服务器3启动==，根据前面的理论分析，==服务器3成为服务器1、2、3中的老大==，而与上面不同的是，此时有三台服务器选举了它，所以==它成为了这次选举的leader==。

（4）==服务器4启动==，根据前面的分析，理论上服务器4应该是服务器1、2、3、4中最大的，但是==由于前面已经有半数以上的服务器选举了服务器3==，所以它只能接收当小弟的命了。

（5）==服务器5启动，同4一样当小弟==。

### 1.1 首先比较什么

> 谁的数据比较新，即比较==更新的日志zxid的序号==，==谁的大谁当老大==，但是==跟启动顺序有很大的关系==
>
> 比如三台zookeeper服务器，前两台比较zxid比较小的已经选出了老大，你最后启动也得不到老大的位置

### 1.2 然后比较什么

>当然是==myid==，谁的myid大，就沟通最后投给谁，==当前情况下==就投给谁

### 1.3 实时的老大如何成为最终的老大

> 选票过半

## 2、zookeeper的节点类型

1. Znode有两种类型：

>  ==短暂（ephemeral）==：客户端和服务器端断开连接后，创建的节点自动删除
>
> ==持久（persistent）==：客户端和服务器端断开连接后，创建的节点不删除

2. Znode有四种形式的目录节点（默认是persistent ）

> ==持久化目录节点（PERSISTENT）==

​    客户端与zookeeper断开连接后，该节点依旧存在,直接的==create命令==

> ==持久化顺序编号目录节点（PERSISTENT_SEQUENTIAL）==

​    客户端与zookeeper断开连接后，该节点依旧存在，只是Zookeeper给该节点名称进行顺序编号，直接的==create -s命令==

> ==临时目录节点（EPHEMERAL）==

客户端与zookeeper断开连接后，该节点被删除，==create -e命令==

> ==临时顺序编号目录节点（EPHEMERAL_SEQUENTIAL）==

客户端与zookeeper断开连接后，该节点被删除，只是Zookeeper给该节点名称进行顺序编号，==create -e -s命令==

## 3、zookeeper监听器原理

> 其实很简单，就是zookeeper客户端开了两个线程，==一个负责监听==，==一个负责通信==，==通信的线程==传递要监听的事件到zookeeper服务器去注册，==监听的事件有变化则发给监听线程去处理==

<img src="zookeeper%E7%AC%94%E8%AE%B0.assets/image-20210228101725427.png" alt="image-20210228101725427" style="zoom:80%;" />

>  ==监听原理详解：==

1）首先要有一个main()线程

2）在main线程中创建Zookeeper客户端，这时就会创建两个线程，==一个负责网络连接通信（connet），一个负责监听（listener）==。

3）通过==connect线程==将注册的监听事件==发送给Zookeeper==。

4）在Zookeeper的注册监听器列表中将注册的监听事件添加到列表中。

5）Zookeeper监听到有==数据或路径变化==，就会将这个==消息发送给listener线程==。

6）listener线程内部调用了==process（）方法==。

> 常见的监听

1. ==监听节点数据的变化：==

> get path [watch]

2. ==监听子节点增减的变化==

> ls path [watch]

## 4、写数据流程

![image-20210228102228257](zookeeper%E7%AC%94%E8%AE%B0.assets/image-20210228102228257.png)

其实也很简单，就是==客户端告诉话事人（<font color=red>可能被转达到话事人，不是直接找到的话事人</font>），话事人通知小弟干活，半数以上人干好了，通知客户端ok==